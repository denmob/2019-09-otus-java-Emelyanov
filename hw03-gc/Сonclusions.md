## Настройки для тестирования работы GC:

* Количество независимых потоков для загрузки данных в память = 3
* Количество итераций добавления данных в коллекцию  = 5000/5000/10000
* Все потоки имеют разный объем данных для загрузки в память = 5/15/30 KB
> Сделано для более равномерного распределения данных в памяти.
* В процессе загрузки памяти, 50% элементов освобождается, для активации работы GC.
* Настройки для всех GC - по умолчанию.
---
 -Xms128m
 -Xmx128m
 -Xlog:gc=debug:file=C:\logs\gc-%p-%t.log:tags,uptime,time,level:filecount=5,filesize=10m
 -XX:+HeapDumpOnOutOfMemoryError
 -XX:HeapDumpPath=C:\\logs\dump
 ---
> Предполагается, что конфигурация по умолчанию, оптимальна для большинства случаев.


---
##  Результирующая таблица

| GC | Young Quantity |  Young Duration(ms) | Old Quantity |  Old Duration(ms) | Time for OutOfMemory (min)
| --- | --- | --- | --- | --- | --- |
| `Serial ` | 6 | 38 | 33 | 218 | 8
| `CMS ` | 22 | 46 | 137 | 43130 | 8
| `G1 ` | 36 | 102 | 30 | 163 | 8


##  Выводы

 Serial 
 * Данные большими порциями перемещались в Old generation.
 * Общее количество запусков и время работы GC вполне адекватное для работы, которую нужно было сделать.

 Хороший выбор для приложений по сложности схожих на инструменты тестирования.

 CMS 
 * Объекты быстро перемещались в Old generation
 * В основном работа велась над маркировкий/перемаркировкой объектов. (initial/concurrent/remark mark)
 * Общее количество запусков и время работы GC неадекватное для работы, которую нужно было сделать.
 
Данный сборщик явно сфокусирован на основательном подходе и обработке большого количества данных.
Работы делает много, из-за множества стадий, но за счет паралельного выполнения, это не так страшно.
Для мелких приложений он не оптимален.

G1

*  Сбалансированя работа над поколениями young, old. Как  по времени так и по количеству запусков.

Исходя из результатов работы, подход, который используется в G1, на текущий момент оптимален.
Перепомечать блоки в одном пространстве проще(нужно меньше запусков) и быстрее(минимальная работа на запуск)

---
В целом много разных критериев влияет на работу сборщика.

Думаю стоит в первую очередь смотреть не надо количество сборок/времени работы конкретного сборщика, а обеспечивается ли нужные задержки/пропускная способность в приложении.
Так же необходимо иметь информацию о том, что является причиной частичной или полной остановкой GC.

После этого можно выбрать оптимальный GC и приступить к его тюнингу.